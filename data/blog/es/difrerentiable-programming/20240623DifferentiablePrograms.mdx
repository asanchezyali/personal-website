---
title: 'Programas Parametrizados: Una Introducción a la Diferenciación Automática'
date: '2024/06/23'
tags: ['matemáticas', 'ciencias de la computación']
draft: false.
time: '15 min'
summary: 'Las redes neuronales pueden ser pensadas como programas parametrizados: programas con parámetros por aprender. En este artículo, exploraremos cómo representar los programas parametrizados matemáticamente. En particular, veremos como los programas pueden ser representados como grafos de computación y como la diferenciación automática puede ser utilizada para calcular derivadas de programas de manera eficiente.'
bibliography: references-data.bib
canonicalUrl: 'https://www.asanchezyali.com/blog/es/number-theory/20230108DivisionAlgorithm/'
headerImage: '/images/differentiable-programs/header.avif'
language: 'es'
---

Las redes neuronales pueden ser pensadas como programas parametrizados, es decir, programas con parámetros ajustables
que se aprenden. En este
artículo, exploraremos cómo representar matemáticamente estos programas. En particular, veremos como los programas pueden ser
representados como grafos dirigidos no cíclicos y cómo la diferenciación automática puede ser utilizada para calcular derivadas
de programas de manera eficiente.

## Cadenas de computación

Para comenzar, consideremos programas simples dados por una **secuencia** de funciones $f_1, \ldots, f_n$ que se aplican
de forma secuencial a una entrada
$s_0 \in S_{0}.$ A estos programas los llamaremos **cadenas de computación** y los denotaremos como $f = f_n \circ \cdots
\circ f_1.$ Por ejemplo, una imagen puede pasar a través de una secuencia de transformaciones tales como recortar,
rotar, normalizar, etc. En el caso de las redes neuronales, las transformaciones suelen estar parametrizadas y los
parámetros se aprenden a través de un proceso de optimización.

<ImageBox
  src="/images/differentiable-programs/figure1.svg"
  alt="Computation Chain"
  width="700px"
  height="150px"
>
  Figura 1. Una cadena de computación es una secuencia de composiciones de funciones. En el gráfico
  anterior, cada nodo intermedio representa una función. La primera flecha representa la entrada, y
  la última la salida. Las flechas interiores representan las dependencias de las funciones con
  respecto a las salidas previas o el entrada inicial.
</ImageBox>

Formalmente, una cadena de computación puede ser escrita como:

$$
\begin{equation}
\begin{aligned}
s_0 &\in S_{0}, \\
s_{1} &= f_{1}(s_{0}) \in S_{1}, \\
s_{2} &= f_{2}(s_{1}) \in S_{2}, \\
&\vdots \\
s_{n} &= f_{n}(s_{n-1}) = f(s_0) \in S_{n}.\\
\end{aligned}
\end{equation}
$$

Donde $s_0$ es la **entrada**, $s_k\in S_k$ para $k = 1, \ldots,
 n-1,$ son los **estados intermedios** del programa y $s_n\in S_n$ es la
**salida**. Por supuesto, el dominio (espacios de entrada) de $f_k$ debe ser compatible con la imagen (espacio de
salida) de $f_{k-1}$ para que la composición tenga sentido. Es decir, que $f_k: S_{k-1} \to S_k$ para $k = 1, \ldots,
 n.$ De manera equivalente a la ecuación (1), podemos escribir la cadena de computación como:

$$
\begin{equation}
s_n = f(s_0) = f_n \circ \cdots \circ f_1(s_0).
\end{equation}
$$

Una cadena de computación puede ser representada como un **grafo dirigido acíclico (DAG)**, donde los nodos representan
las funciones y las aristas representan las dependencias entre las funciones.

## Grafos acíclicos dirigidos

En un programa genérico, las funciones intermedias pueden depender de las salidas de otras funciones. Tales dependencias
pueden ser representadas como un grafo dirigido acíclico (DAG). Un **grafo dirigido** $G = (V, E)$ consiste de un
conjunto de nodos $V$ y un conjunto de aristas $E\subseteq V \times V.$ Un arista $(u, v) \in E$ es un par ordenad de
vertices $u, v\in V$. Es también representado como $u \to v.$, para indicar que $u$ depende de $v.$ Para representar las
entradas y las salidas, será conveniente usar **semi-aristas entrantes** $\to j$ y **semi-aristas salientes** $i \to.$

En un grafo $G = (V, E)$, los **padres** de un nodo $v\in V$ son los nodos $u\in V$ tales que $(u, v)\in E,$ denotado
por

$$
\begin{equation}
\text{Padres}(v) = \{u\in V: (u, v)\in E\}.
\end{equation}
$$

De manera similar, los **hijos** de un nodo $v\in V$ son los nodos $w\in V$ tales que $(v, w)\in E,$ denotado por

$$
\begin{equation}
\text{Hijos}(v) = \{w\in V: (v, w)\in E\}.
\end{equation}
$$

Los vertices sin padres son llamados **raíces** y los vertices sin hijos son llamados **hojas**.

Un **camino** de $i$ a $j$ en un grafo $G = (V, E)$ es una secuencia de nodos $v_1, \ldots, v_k$ tal que $i \to v_1 \to
\cdots \to v_k \to j.$ Un camino es **simple** si no contiene nodos repetidos. Un grafo es **acíclico** si no contiene
ciclos, es decir, no hay caminos simples de un nodo a sí mismo. Un grafo acíclico dirigido (DAG) es un grafo dirigido
que es acíclico.

La aristas de un DAG inducen un **orden parcial** en los nodos, que denotaremos por $i \preceq j$ si existe un camino de
$i$ a $j.$ Un orden parcial es una relación reflexiva, transitiva y antisimétrica. El orden es parcial porque no todos
los nodos están relacionados entre sí. No obstante, podemos definir un **orden total** llamado **orden topológico**:
cualquier orden tal que $i \preceq j$ si y solo si no hay un camino de $j$ a $i.$

## Programas computacionales como DAGs

Nosotros que un programa computacional es una función valida en el sentido matemático, es decir, el programa debería
retornar valores idénticos para las mismas entradas y no debería tener efectos secundarios. También asumimos que el
programa se detiene en un número finito de pasos. Por lo tanto, un programa puede estar hecho de un número finito de
funciones intermedias y variables intermedias, de tal forma que las dependencias entres las funciones y las variables
pueden ser representados como un grafo dirigido acíclico. Sin perdida de generalidad, podemos hacer las siguientes
suposiciones:

1. Existe un nodo **entrada** $s_0$ y un nodo **salida** $s_n.$
2. Cada función intermedia $f_k$ produce un solo valor $s_k \in S_k.$

Con un número finito de nodos como $V = \{0, 1, \ldots, n\}$. El node $0$ es una raíz, correspondiente a la
entrada del programa, y el nodo $n$ es una hoja, correspondiente a la salida del programa. Las funciones intermedias.
Debido al tercer supuesto, aparte de $s_0$, cada variable $s_k$ está en biyección con una función $f_k.$ Por lo tanto,
el node $0$ representa la entrada $s_0$, y los nodos $1, \ldots, n$ representan las funciones $f_1, \ldots,
f_n$ y salidas $s_1, \ldots, s_n,$ es decir un nodo $k$ representa la función $f_k$ y la salida $s_k.$

Las aristas de un DAG representan las dependencias. Los padres

## Imágenes

- [Unplash](https://unsplash.com/photos/blue-neurons-with-glowing-segments-over-blue-background-neuron-interface-and-computer-science-concept-3d-rendering-copy-space-G1FpRJcLoCw) - Getty Images - Neurons.

## Referencias

1. [Mathieu Blondel and Vincent Roulet. 2024. The Elements of Differentiable Programming.](https://arxiv.org/pdf/2403.14606)
